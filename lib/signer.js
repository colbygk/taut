const crypto = require('crypto');
const pako = require('pako');

var Signer = module.exports = {
    /**
     * Port of Python's base64.urlsafe_b64encode: Returns a base64-encoded
     * representation of s, made URL-safe by replacing + and / with - and _
     * respectively. Additionally all trailing =s are stripped from the
     * resulting value to mirror django.core.signing.b64_encode.
     *
     * @param  {string} s String to encode
     *
     * @return {string}
     */
    b64UrlSafeEncode: function (s) {
        var b64String = Buffer(s, 'binary').toString('base64');
        return b64String.replace(
            /[+\/]/g,
            function (c) {return {'+':'-', '/':'_'}[c];}
        ).replace(/=+$/, '');
    },

    /**
     * Port of Python's base64.urlsafe_b64decode: Returns a base64-decoded
     * representation of s, made URL-safe by replacing + and / with - and _
     * respectively. Handles removal of trailing =s which are stripped from
     * encoded values to mirror django.core.signing.b64_decode.
     * @param  {string} s String to decode
     * @return {string}
     */
    b64UrlSafeDecode: function (s) {
        if (s[0] === '.') s = s.substring(1);
        s = s.replace(/[-_]/g, function (c) {return {'-':'+', '_':'/'}[c]; });
        return new Buffer(s, 'base64').toString('binary');
    },

    /**
     * Method for obtaining the key for the HMAC-SHA1
     *
     * @param  {string} key_salt
     * @param  {string} secret
     *
     * @return {buffer} binary sha1 digest of key_salt + secret
     */
    getSaltedHmacKey: function (salt, secret) {
        var keySha1Sum = crypto.createHash('sha1');
        keySha1Sum.update(salt + secret);
        return keySha1Sum.digest('binary');
    },

    /**
     * Port of django.utils.crypto.salted_hmac:
     * Returns the HMAC-SHA1 of 'value', using a key generated from key_salt and
     * a secret
     *
     * @param  {string} key_salt
     * @param  {string} value
     * @param  {string} secret
     *
     * @return {object} crypto.Hmac
     */
    getSaltedHmac: function (salt, value, secret) {
        var hmac = crypto.createHmac(
            'sha1', Signer.getSaltedHmacKey(salt, secret));
        hmac.update(value);
        return hmac;
    },

    /**
     * Port of django.core.signing.base64_hmac:
     * Returns a URL-safe base64 encoded representation of the digest of the
     * HMAC of 'value'.
     *
     * @param  {string} salt
     * @param  {string} value
     * @param  {string} key
     *
     * @return {string}
     */
    base64Hmac: function (salt, value, key) {
        var saltedHmac = Signer.getSaltedHmac(salt + 'signer', value, key);
        return Signer.b64UrlSafeEncode(saltedHmac.digest('binary'));
    },

    /**
     * Return an MD5 hash of value
     */
    md5: function (value) {
        return crypto.createHash('md5').update(value).digest('hex');
    },

    /**
     * Port of django.core.signing.Signer.unsign
     *
     * @param  {string} salt
     * @param  {string} signedString String in the form value:time:signature
     * @param  {string} key
     * @param  {function} callback
     *
     * @return {void}
     */
    unsign: function (salt, signedString, secret) {
        // Validate
        if (typeof signedString !== 'string') return;
        if (signedString.indexOf(':') === -1) return;

        // Decode
        var components = signedString.split(':');
        var value = components.slice(0,-1).join(':');
        var signature = components.slice(-1)[0];
        var challenge = Signer.base64Hmac(salt, value, secret);

        // Compare signature to challenge
        if (Signer.md5(signature) !== Signer.md5(challenge)) return;
        return value;
    },

    /**
     * Return the usable content portion of a signed, compressed cookie
     * generated by Django's signing module
     * See: github.com/django/django/blob/stable/1.8.x/django/core/signing.py
     * @param {string} Signed (and optionally compressed) cookie
     * @return {object}
     */
    unpack: function (s) {
        // Validate
        if (typeof s !== 'string') return;

        // Storage objects
        const decompress = (s[0] === '.');
        const b64data = s.split(':')[0];

        // Base64 decode
        var result = Signer.b64UrlSafeDecode(b64data);

        try {
            // Handle decompression
            if (decompress) {
                var charData = result.split('').map(function (c) {
                    return c.charCodeAt(0);
                });
                var binData = new Uint8Array(charData);
                var data = pako.inflate(binData);
                result = String.fromCharCode.apply(null, new Uint16Array(data));
            }

            // Convert to object
            result = JSON.parse(result);
        } catch (e) {
            return;
        }

        return result;
    }
};
